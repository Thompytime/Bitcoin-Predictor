{"ast":null,"code":"import { UPLOADS_STORAGE_KEY } from '../../../../utils/constants.mjs';\nimport '../../../../utils/client/s3data/base.mjs';\nimport '../../../../utils/client/s3data/getObject.mjs';\nimport '../../../../utils/client/s3data/listObjectsV2.mjs';\nimport '../../../../utils/client/s3data/putObject.mjs';\nimport '../../../../utils/client/s3data/createMultipartUpload.mjs';\nimport '../../../../utils/client/s3data/uploadPart.mjs';\nimport '../../../../utils/client/s3data/completeMultipartUpload.mjs';\nimport { listParts } from '../../../../utils/client/s3data/listParts.mjs';\nimport '../../../../utils/client/s3data/abortMultipartUpload.mjs';\nimport '../../../../utils/client/s3data/copyObject.mjs';\nimport '../../../../utils/client/s3data/headObject.mjs';\nimport '../../../../utils/client/s3data/deleteObject.mjs';\nimport '../../../../../../errors/types/validation.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport { logger } from '../../../../../../utils/logger.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst ONE_HOUR = 1000 * 60 * 60;\n/**\n * Find the cached multipart upload id and get the parts that have been uploaded\n * with ListParts API. If the cached upload is expired(1 hour), return null.\n */\nconst findCachedUploadParts = async ({\n  resumableUploadsCache,\n  cacheKey,\n  s3Config,\n  bucket,\n  finalKey\n}) => {\n  const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n  if (!cachedUploads[cacheKey] || cachedUploads[cacheKey].lastTouched < Date.now() - ONE_HOUR // Uploads are cached for 1 hour\n  ) {\n    return null;\n  }\n  const cachedUpload = cachedUploads[cacheKey];\n  cachedUpload.lastTouched = Date.now();\n  await resumableUploadsCache.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n  try {\n    const {\n      Parts = []\n    } = await listParts(s3Config, {\n      Bucket: bucket,\n      Key: finalKey,\n      UploadId: cachedUpload.uploadId\n    });\n    return {\n      parts: Parts,\n      uploadId: cachedUpload.uploadId,\n      finalCrc32: cachedUpload.finalCrc32\n    };\n  } catch (e) {\n    logger.debug('failed to list cached parts, removing cached upload.');\n    await removeCachedUpload(resumableUploadsCache, cacheKey);\n    return null;\n  }\n};\nconst listCachedUploadTasks = async resumableUploadsCache => {\n  try {\n    return JSON.parse((await resumableUploadsCache.getItem(UPLOADS_STORAGE_KEY)) ?? '{}');\n  } catch (e) {\n    logger.debug('failed to parse cached uploads record.');\n    return {};\n  }\n};\n/**\n * Serialize the uploadData API options to string so it can be hashed.\n */\nconst serializeUploadOptions = (options = {}) => {\n  const unserializableOptionProperties = ['onProgress', 'resumableUploadsCache', 'locationCredentialsProvider' // Internally injected implementation not set by customers\n  ];\n  const serializableOptions = Object.fromEntries(Object.entries(options).filter(([key]) => !unserializableOptionProperties.includes(key)));\n  return JSON.stringify(serializableOptions);\n};\n/**\n * Get the cache key of a multipart upload. Data source cached by different: size, content type, bucket, access level,\n * key. If the data source is a File instance, the upload is additionally indexed by file name and last modified time.\n * So the library always created a new multipart upload if the file is modified.\n */\nconst getUploadsCacheKey = ({\n  file,\n  size,\n  contentType,\n  bucket,\n  accessLevel,\n  key,\n  optionsHash\n}) => {\n  let levelStr;\n  const resolvedContentType = contentType ?? file?.type ?? 'application/octet-stream';\n  // If no access level is defined, we're using custom gen2 access rules\n  if (accessLevel === undefined) {\n    levelStr = 'custom';\n  } else {\n    levelStr = accessLevel === 'guest' ? 'public' : accessLevel;\n  }\n  const baseId = `${optionsHash}_${size}_${resolvedContentType}_${bucket}_${levelStr}_${key}`;\n  if (file) {\n    return `${file.name}_${file.lastModified}_${baseId}`;\n  } else {\n    return baseId;\n  }\n};\nconst cacheMultipartUpload = async (resumableUploadsCache, cacheKey, fileMetadata) => {\n  const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n  cachedUploads[cacheKey] = {\n    ...fileMetadata,\n    lastTouched: Date.now()\n  };\n  await resumableUploadsCache.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nconst removeCachedUpload = async (resumableUploadsCache, cacheKey) => {\n  const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n  delete cachedUploads[cacheKey];\n  await resumableUploadsCache.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexport { cacheMultipartUpload, findCachedUploadParts, getUploadsCacheKey, removeCachedUpload, serializeUploadOptions };","map":{"version":3,"names":["ONE_HOUR","findCachedUploadParts","resumableUploadsCache","cacheKey","s3Config","bucket","finalKey","cachedUploads","listCachedUploadTasks","lastTouched","Date","now","cachedUpload","setItem","UPLOADS_STORAGE_KEY","JSON","stringify","Parts","listParts","Bucket","Key","UploadId","uploadId","parts","finalCrc32","e","logger","debug","removeCachedUpload","parse","getItem","serializeUploadOptions","options","unserializableOptionProperties","serializableOptions","Object","fromEntries","entries","filter","key","includes","getUploadsCacheKey","file","size","contentType","accessLevel","optionsHash","levelStr","resolvedContentType","type","undefined","baseId","name","lastModified","cacheMultipartUpload","fileMetadata"],"sources":["C:\\Users\\lvsct\\Desktop\\bitcoin-prediction\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\apis\\internal\\uploadData\\multipart\\uploadCache.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { UPLOADS_STORAGE_KEY } from '../../../../utils/constants';\nimport { listParts } from '../../../../utils/client/s3data';\nimport { logger } from '../../../../../../utils';\nconst ONE_HOUR = 1000 * 60 * 60;\n/**\n * Find the cached multipart upload id and get the parts that have been uploaded\n * with ListParts API. If the cached upload is expired(1 hour), return null.\n */\nexport const findCachedUploadParts = async ({ resumableUploadsCache, cacheKey, s3Config, bucket, finalKey, }) => {\n    const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n    if (!cachedUploads[cacheKey] ||\n        cachedUploads[cacheKey].lastTouched < Date.now() - ONE_HOUR // Uploads are cached for 1 hour\n    ) {\n        return null;\n    }\n    const cachedUpload = cachedUploads[cacheKey];\n    cachedUpload.lastTouched = Date.now();\n    await resumableUploadsCache.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n    try {\n        const { Parts = [] } = await listParts(s3Config, {\n            Bucket: bucket,\n            Key: finalKey,\n            UploadId: cachedUpload.uploadId,\n        });\n        return {\n            parts: Parts,\n            uploadId: cachedUpload.uploadId,\n            finalCrc32: cachedUpload.finalCrc32,\n        };\n    }\n    catch (e) {\n        logger.debug('failed to list cached parts, removing cached upload.');\n        await removeCachedUpload(resumableUploadsCache, cacheKey);\n        return null;\n    }\n};\nconst listCachedUploadTasks = async (resumableUploadsCache) => {\n    try {\n        return JSON.parse((await resumableUploadsCache.getItem(UPLOADS_STORAGE_KEY)) ?? '{}');\n    }\n    catch (e) {\n        logger.debug('failed to parse cached uploads record.');\n        return {};\n    }\n};\n/**\n * Serialize the uploadData API options to string so it can be hashed.\n */\nexport const serializeUploadOptions = (options = {}) => {\n    const unserializableOptionProperties = [\n        'onProgress',\n        'resumableUploadsCache',\n        'locationCredentialsProvider', // Internally injected implementation not set by customers\n    ];\n    const serializableOptions = Object.fromEntries(Object.entries(options).filter(([key]) => !unserializableOptionProperties.includes(key)));\n    return JSON.stringify(serializableOptions);\n};\n/**\n * Get the cache key of a multipart upload. Data source cached by different: size, content type, bucket, access level,\n * key. If the data source is a File instance, the upload is additionally indexed by file name and last modified time.\n * So the library always created a new multipart upload if the file is modified.\n */\nexport const getUploadsCacheKey = ({ file, size, contentType, bucket, accessLevel, key, optionsHash, }) => {\n    let levelStr;\n    const resolvedContentType = contentType ?? file?.type ?? 'application/octet-stream';\n    // If no access level is defined, we're using custom gen2 access rules\n    if (accessLevel === undefined) {\n        levelStr = 'custom';\n    }\n    else {\n        levelStr = accessLevel === 'guest' ? 'public' : accessLevel;\n    }\n    const baseId = `${optionsHash}_${size}_${resolvedContentType}_${bucket}_${levelStr}_${key}`;\n    if (file) {\n        return `${file.name}_${file.lastModified}_${baseId}`;\n    }\n    else {\n        return baseId;\n    }\n};\nexport const cacheMultipartUpload = async (resumableUploadsCache, cacheKey, fileMetadata) => {\n    const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n    cachedUploads[cacheKey] = {\n        ...fileMetadata,\n        lastTouched: Date.now(),\n    };\n    await resumableUploadsCache.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexport const removeCachedUpload = async (resumableUploadsCache, cacheKey) => {\n    const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n    delete cachedUploads[cacheKey];\n    await resumableUploadsCache.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AAIA,MAAMA,QAAQ,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE;AAC/B;AACA;AACA;AACA;AACY,MAACC,qBAAqB,GAAG,MAAAA,CAAO;EAAEC,qBAAqB;EAAEC,QAAQ;EAAEC,QAAQ;EAAEC,MAAM;EAAEC;AAAQ,CAAG,KAAK;EAC7G,MAAMC,aAAa,GAAG,MAAMC,qBAAqB,CAACN,qBAAqB,CAAC;EACxE,IAAI,CAACK,aAAa,CAACJ,QAAQ,CAAC,IACxBI,aAAa,CAACJ,QAAQ,CAAC,CAACM,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE,GAAGX,QAAQ;EAAA,EAC7D;IACE,OAAO,IAAI;EACnB;EACI,MAAMY,YAAY,GAAGL,aAAa,CAACJ,QAAQ,CAAC;EAC5CS,YAAY,CAACH,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;EACrC,MAAMT,qBAAqB,CAACW,OAAO,CAACC,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACT,aAAa,CAAC,CAAC;EACvF,IAAI;IACA,MAAM;MAAEU,KAAK,GAAG;IAAE,CAAE,GAAG,MAAMC,SAAS,CAACd,QAAQ,EAAE;MAC7Ce,MAAM,EAAEd,MAAM;MACde,GAAG,EAAEd,QAAQ;MACbe,QAAQ,EAAET,YAAY,CAACU;IACnC,CAAS,CAAC;IACF,OAAO;MACHC,KAAK,EAAEN,KAAK;MACZK,QAAQ,EAAEV,YAAY,CAACU,QAAQ;MAC/BE,UAAU,EAAEZ,YAAY,CAACY;IACrC,CAAS;EACT,CAAK,CACD,OAAOC,CAAC,EAAE;IACNC,MAAM,CAACC,KAAK,CAAC,sDAAsD,CAAC;IACpE,MAAMC,kBAAkB,CAAC1B,qBAAqB,EAAEC,QAAQ,CAAC;IACzD,OAAO,IAAI;EACnB;AACA;AACA,MAAMK,qBAAqB,GAAG,MAAON,qBAAqB,IAAK;EAC3D,IAAI;IACA,OAAOa,IAAI,CAACc,KAAK,CAAC,CAAC,MAAM3B,qBAAqB,CAAC4B,OAAO,CAAChB,mBAAmB,CAAC,KAAK,IAAI,CAAC;EAC7F,CAAK,CACD,OAAOW,CAAC,EAAE;IACNC,MAAM,CAACC,KAAK,CAAC,wCAAwC,CAAC;IACtD,OAAO,EAAE;EACjB;AACA,CAAC;AACD;AACA;AACA;AACY,MAACI,sBAAsB,GAAGA,CAACC,OAAO,GAAG,EAAE,KAAK;EACpD,MAAMC,8BAA8B,GAAG,CACnC,YAAY,EACZ,uBAAuB,EACvB,6BAA6B;EAAA,CAChC;EACD,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,WAAW,CAACD,MAAM,CAACE,OAAO,CAACL,OAAO,CAAC,CAACM,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,KAAK,CAACN,8BAA8B,CAACO,QAAQ,CAACD,GAAG,CAAC,CAAC,CAAC;EACxI,OAAOxB,IAAI,CAACC,SAAS,CAACkB,mBAAmB,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACY,MAACO,kBAAkB,GAAGA,CAAC;EAAEC,IAAI;EAAEC,IAAI;EAAEC,WAAW;EAAEvC,MAAM;EAAEwC,WAAW;EAAEN,GAAG;EAAEO;AAAW,CAAG,KAAK;EACvG,IAAIC,QAAQ;EACZ,MAAMC,mBAAmB,GAAGJ,WAAW,IAAIF,IAAI,EAAEO,IAAI,IAAI,0BAA0B;EACvF;EACI,IAAIJ,WAAW,KAAKK,SAAS,EAAE;IAC3BH,QAAQ,GAAG,QAAQ;EAC3B,CAAK,MACI;IACDA,QAAQ,GAAGF,WAAW,KAAK,OAAO,GAAG,QAAQ,GAAGA,WAAW;EACnE;EACI,MAAMM,MAAM,GAAG,GAAGL,WAAW,IAAIH,IAAI,IAAIK,mBAAmB,IAAI3C,MAAM,IAAI0C,QAAQ,IAAIR,GAAG,EAAE;EAC3F,IAAIG,IAAI,EAAE;IACN,OAAO,GAAGA,IAAI,CAACU,IAAI,IAAIV,IAAI,CAACW,YAAY,IAAIF,MAAM,EAAE;EAC5D,CAAK,MACI;IACD,OAAOA,MAAM;EACrB;AACA;AACY,MAACG,oBAAoB,GAAG,MAAAA,CAAOpD,qBAAqB,EAAEC,QAAQ,EAAEoD,YAAY,KAAK;EACzF,MAAMhD,aAAa,GAAG,MAAMC,qBAAqB,CAACN,qBAAqB,CAAC;EACxEK,aAAa,CAACJ,QAAQ,CAAC,GAAG;IACtB,GAAGoD,YAAY;IACf9C,WAAW,EAAEC,IAAI,CAACC,GAAG;EAC7B,CAAK;EACD,MAAMT,qBAAqB,CAACW,OAAO,CAACC,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACT,aAAa,CAAC,CAAC;AAC3F;AACY,MAACqB,kBAAkB,GAAG,MAAAA,CAAO1B,qBAAqB,EAAEC,QAAQ,KAAK;EACzE,MAAMI,aAAa,GAAG,MAAMC,qBAAqB,CAACN,qBAAqB,CAAC;EACxE,OAAOK,aAAa,CAACJ,QAAQ,CAAC;EAC9B,MAAMD,qBAAqB,CAACW,OAAO,CAACC,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACT,aAAa,CAAC,CAAC;AAC3F","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}