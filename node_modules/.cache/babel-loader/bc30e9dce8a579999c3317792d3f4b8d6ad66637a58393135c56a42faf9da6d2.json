{"ast":null,"code":"import * as React from 'react';\nimport { isFunction } from '@aws-amplify/ui';\nconst getCorrectSteppingValue = _ref => {\n  let {\n    max,\n    min,\n    step,\n    value\n  } = _ref;\n  // Round it to the closest step value\n  // It will be based off min to be consistent with native input[type=\"number\"]\n  // This allows keyboard accessible\n  const remainder = (value - min) % step;\n  value = value - remainder + Math.round(remainder / step) * step;\n  // Make sure new value is not outside the bound\n  value = Math.max(min, value);\n  if (value > max) {\n    value = max - (max - min) % step;\n  }\n  return value;\n};\nconst useStepper = _ref2 => {\n  let {\n    defaultValue = 0,\n    value: controlledValue,\n    step = 1,\n    max = Number.MAX_SAFE_INTEGER,\n    min = Number.MIN_SAFE_INTEGER,\n    isDisabled,\n    isReadOnly,\n    onChange,\n    onDecrease,\n    onIncrease,\n    onStepChange\n  } = _ref2;\n  const isControlled = controlledValue !== undefined;\n  // Make sure max value is greater than or equal to min value\n  max = Math.max(min, max);\n  // Maintain an internal state for uncontrolled components\n  // This allows to take over the input value and correct any invalid versus purely relying on the native uncontrolled input\n  const [uncontrolledValue, setUncontrolledValue] = React.useState(() =>\n  // This is required for users could provide any defaultValue\n  getCorrectSteppingValue({\n    min,\n    max,\n    step,\n    value: defaultValue\n  }));\n  // Same for controlled components on the first render because users could provide invalid initial value.\n  // It seems redundant afterwards but necessary for the first render\n  const value = isControlled ? getCorrectSteppingValue({\n    min,\n    max,\n    step,\n    value: controlledValue\n  }) : uncontrolledValue;\n  const shouldDisableIncreaseButton = isDisabled ?? isReadOnly ?? value + step > max;\n  const shouldDisableDecreaseButton = isDisabled ?? isReadOnly ?? value - step < min;\n  // This is the exact value to be rendered on screen\n  // It could be a string, like '-' or empty string when users clear the input\n  const [inputValue, setInputValue] = React.useState(value);\n  const handleOnChange = React.useCallback(event => {\n    setInputValue(event.target.value);\n    if (isFunction(onChange)) {\n      onChange(event);\n    }\n  }, [onChange]);\n  const handleOnBlur = React.useCallback(event => {\n    const parsedValue = parseFloat(event.target.value);\n    // Though input[type='number'] has built-in validation to reject non-numerical entries\n    // The entered value could still be empty string or minus '-'\n    // in these cases, no need to do the following validation\n    if (isNaN(parsedValue)) {\n      return;\n    }\n    const newValue = getCorrectSteppingValue({\n      min,\n      max,\n      step,\n      value: parsedValue\n    });\n    if (!isControlled) {\n      setUncontrolledValue(newValue);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(newValue);\n    }\n    setInputValue(newValue);\n  }, [min, max, step, isControlled, onStepChange]);\n  const handleIncrease = React.useCallback(() => {\n    // No need to check if the value will be outside the bounds\n    // The button will be disabled if so\n    if (!isControlled) {\n      setUncontrolledValue(value + step);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(value + step);\n    }\n    if (isFunction(onIncrease)) {\n      onIncrease();\n    }\n    setInputValue(value + step);\n  }, [step, value, isControlled, onIncrease, onStepChange]);\n  const handleDecrease = React.useCallback(() => {\n    // No need to check if the value will be outside the bounds\n    // The button will be disabled if so\n    if (!isControlled) {\n      setUncontrolledValue(value - step);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(value - step);\n    }\n    if (isFunction(onDecrease)) {\n      onDecrease();\n    }\n    setInputValue(value - step);\n  }, [step, value, isControlled, onDecrease, onStepChange]);\n  // This aims to disable unwanted behaviors on React input[type='number']\n  // When the input gets focused, rotating a wheel will change its value\n  // But the parent container(mostly the entire window) will be scrolling to elsewhere\n  const handleOnWheel = React.useCallback(event => {\n    event.currentTarget.blur();\n  }, []);\n  return {\n    step,\n    value,\n    inputValue,\n    handleDecrease,\n    handleIncrease,\n    handleOnBlur,\n    handleOnChange,\n    handleOnWheel,\n    setInputValue,\n    shouldDisableDecreaseButton,\n    shouldDisableIncreaseButton\n  };\n};\nexport { useStepper };","map":{"version":3,"names":["React","isFunction","getCorrectSteppingValue","_ref","max","min","step","value","remainder","Math","round","useStepper","_ref2","defaultValue","controlledValue","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isDisabled","isReadOnly","onChange","onDecrease","onIncrease","onStepChange","isControlled","undefined","uncontrolledValue","setUncontrolledValue","useState","shouldDisableIncreaseButton","shouldDisableDecreaseButton","inputValue","setInputValue","handleOnChange","useCallback","event","target","handleOnBlur","parsedValue","parseFloat","isNaN","newValue","handleIncrease","handleDecrease","handleOnWheel","currentTarget","blur"],"sources":["C:/Users/lvsct/Desktop/bitcoin-prediction/node_modules/@aws-amplify/ui-react/dist/esm/primitives/StepperField/useStepper.mjs"],"sourcesContent":["import * as React from 'react';\nimport { isFunction } from '@aws-amplify/ui';\n\nconst getCorrectSteppingValue = ({ max, min, step, value, }) => {\n    // Round it to the closest step value\n    // It will be based off min to be consistent with native input[type=\"number\"]\n    // This allows keyboard accessible\n    const remainder = (value - min) % step;\n    value = value - remainder + Math.round(remainder / step) * step;\n    // Make sure new value is not outside the bound\n    value = Math.max(min, value);\n    if (value > max) {\n        value = max - ((max - min) % step);\n    }\n    return value;\n};\nconst useStepper = ({ defaultValue = 0, value: controlledValue, step = 1, max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, isDisabled, isReadOnly, onChange, onDecrease, onIncrease, onStepChange, }) => {\n    const isControlled = controlledValue !== undefined;\n    // Make sure max value is greater than or equal to min value\n    max = Math.max(min, max);\n    // Maintain an internal state for uncontrolled components\n    // This allows to take over the input value and correct any invalid versus purely relying on the native uncontrolled input\n    const [uncontrolledValue, setUncontrolledValue] = React.useState(() => \n    // This is required for users could provide any defaultValue\n    getCorrectSteppingValue({ min, max, step, value: defaultValue }));\n    // Same for controlled components on the first render because users could provide invalid initial value.\n    // It seems redundant afterwards but necessary for the first render\n    const value = isControlled\n        ? getCorrectSteppingValue({ min, max, step, value: controlledValue })\n        : uncontrolledValue;\n    const shouldDisableIncreaseButton = isDisabled ?? isReadOnly ?? value + step > max;\n    const shouldDisableDecreaseButton = isDisabled ?? isReadOnly ?? value - step < min;\n    // This is the exact value to be rendered on screen\n    // It could be a string, like '-' or empty string when users clear the input\n    const [inputValue, setInputValue] = React.useState(value);\n    const handleOnChange = React.useCallback((event) => {\n        setInputValue(event.target.value);\n        if (isFunction(onChange)) {\n            onChange(event);\n        }\n    }, [onChange]);\n    const handleOnBlur = React.useCallback((event) => {\n        const parsedValue = parseFloat(event.target.value);\n        // Though input[type='number'] has built-in validation to reject non-numerical entries\n        // The entered value could still be empty string or minus '-'\n        // in these cases, no need to do the following validation\n        if (isNaN(parsedValue)) {\n            return;\n        }\n        const newValue = getCorrectSteppingValue({\n            min,\n            max,\n            step,\n            value: parsedValue,\n        });\n        if (!isControlled) {\n            setUncontrolledValue(newValue);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(newValue);\n        }\n        setInputValue(newValue);\n    }, [min, max, step, isControlled, onStepChange]);\n    const handleIncrease = React.useCallback(() => {\n        // No need to check if the value will be outside the bounds\n        // The button will be disabled if so\n        if (!isControlled) {\n            setUncontrolledValue(value + step);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(value + step);\n        }\n        if (isFunction(onIncrease)) {\n            onIncrease();\n        }\n        setInputValue(value + step);\n    }, [step, value, isControlled, onIncrease, onStepChange]);\n    const handleDecrease = React.useCallback(() => {\n        // No need to check if the value will be outside the bounds\n        // The button will be disabled if so\n        if (!isControlled) {\n            setUncontrolledValue(value - step);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(value - step);\n        }\n        if (isFunction(onDecrease)) {\n            onDecrease();\n        }\n        setInputValue(value - step);\n    }, [step, value, isControlled, onDecrease, onStepChange]);\n    // This aims to disable unwanted behaviors on React input[type='number']\n    // When the input gets focused, rotating a wheel will change its value\n    // But the parent container(mostly the entire window) will be scrolling to elsewhere\n    const handleOnWheel = React.useCallback((event) => {\n        event.currentTarget.blur();\n    }, []);\n    return {\n        step,\n        value,\n        inputValue,\n        handleDecrease,\n        handleIncrease,\n        handleOnBlur,\n        handleOnChange,\n        handleOnWheel,\n        setInputValue,\n        shouldDisableDecreaseButton,\n        shouldDisableIncreaseButton,\n    };\n};\n\nexport { useStepper };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}